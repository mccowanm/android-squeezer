/*
 * Copyright (c) 2009 Google Inc.  All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package uk.org.ngo.squeezer.service;

import android.Manifest;
import android.app.Notification;
import android.app.PendingIntent;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.graphics.BitmapFactory;
import android.media.AudioManager;
import android.media.MediaMetadata;
import android.net.Uri;
import android.net.wifi.WifiManager;
import android.os.Binder;
import android.os.Build;
import android.os.IBinder;
import android.os.PowerManager;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import androidx.core.app.NotificationCompat;
import androidx.core.app.NotificationManagerCompat;
import androidx.core.content.ContextCompat;
import androidx.media.VolumeProviderCompat;

import android.support.v4.media.MediaMetadataCompat;
import android.support.v4.media.session.MediaSessionCompat;
import android.support.v4.media.session.PlaybackStateCompat;
import android.telephony.PhoneStateListener;
import android.telephony.TelephonyCallback;
import android.telephony.TelephonyManager;
import android.util.Log;

import org.greenrobot.eventbus.EventBus;
import org.greenrobot.eventbus.Subscribe;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import uk.org.ngo.squeezer.NowPlayingActivity;
import uk.org.ngo.squeezer.Preferences;
import uk.org.ngo.squeezer.R;
import uk.org.ngo.squeezer.Squeezer;
import uk.org.ngo.squeezer.Util;
import uk.org.ngo.squeezer.download.DownloadDatabase;
import uk.org.ngo.squeezer.model.Action;
import uk.org.ngo.squeezer.model.JiveItem;
import uk.org.ngo.squeezer.model.MusicFolderItem;
import uk.org.ngo.squeezer.model.SlimCommand;
import uk.org.ngo.squeezer.itemlist.IServiceItemListCallback;
import uk.org.ngo.squeezer.model.Alarm;
import uk.org.ngo.squeezer.model.AlarmPlaylist;
import uk.org.ngo.squeezer.model.CurrentPlaylistItem;
import uk.org.ngo.squeezer.model.Player;
import uk.org.ngo.squeezer.model.PlayerState;
import uk.org.ngo.squeezer.model.Song;
import uk.org.ngo.squeezer.service.event.ConnectionChanged;
import uk.org.ngo.squeezer.service.event.HandshakeComplete;
import uk.org.ngo.squeezer.service.event.MusicChanged;
import uk.org.ngo.squeezer.service.event.PlayStatusChanged;
import uk.org.ngo.squeezer.service.event.PlayerVolume;
import uk.org.ngo.squeezer.service.event.PlayersChanged;
import uk.org.ngo.squeezer.util.ImageFetcher;
import uk.org.ngo.squeezer.util.Intents;
import uk.org.ngo.squeezer.util.NotificationUtil;
import uk.org.ngo.squeezer.util.Scrobble;

/**
 * Persistent service which acts as an interface to for activities to communicate with LMS.
 * <p>
 * The interface is documented here {@link ISqueezeService}
 * <p>
 * The service lifecycle is managed as both a bound and a started servic. as follows.
 * <ul>
 *     <li>On connect to LMS call Context.start[Foreground]Service and Service.startForeground</li>
 *     <li>On disconnect from LMS call Service.stopForeground and Service.stopSelf</li>
 *     <li>bind to the SqueezeService in activities in onCreate</li>
 *     <li>unbind the SqueezeService in activities  onDestroy</li>
 * </ul>
 * This means the service will as long as there is a Squeezer or we are connected to LMS activity.
 * When we are connected to LMS it runs as a foreground service and a notification is displayed.
 */
public class SqueezeService extends Service {

    private static final String TAG = "SqueezeService";

    public static final String NOTIFICATION_CHANNEL_ID = "channel_squeezer_1";
    private static final int PLAYBACKSERVICE_STATUS = 1;
    public static final int DOWNLOAD_ERROR = 2;

    /** Service-specific eventbus. All events generated by the service will be sent here. */
    private final EventBus mEventBus = EventBus.builder()
            .logNoSubscriberMessages(false)
            .sendNoSubscriberEvent(false)
            .build();

    /** True if the handshake with the server has completed, otherwise false. */
    private volatile boolean mHandshakeComplete = false;

    /** Media session to associate with ongoing notifications. */
    private MediaSessionCompat mMediaSession;

    /** Are the service currently in the foregrund */
    private volatile boolean foreGround;

    /** The most recent notifcation. */
    private NotificationState ongoingNotification;

    private final SlimDelegate mDelegate = new SlimDelegate(mEventBus);

    private final RandomPlayDelegate randomPlayDelegate = new RandomPlayDelegate(mDelegate);

    /**
     * Is scrobbling enabled?
     */
    private boolean scrobblingEnabled;

    /**
     * Was scrobbling enabled?
     */
    private boolean scrobblingPreviouslyEnabled;

    int mFadeInSecs;
    boolean mGroupVolume;

    private static final String ACTION_NEXT_TRACK = "uk.org.ngo.squeezer.service.ACTION_NEXT_TRACK";
    private static final String ACTION_PREV_TRACK = "uk.org.ngo.squeezer.service.ACTION_PREV_TRACK";
    private static final String ACTION_PLAY = "uk.org.ngo.squeezer.service.ACTION_PLAY";
    private static final String ACTION_PAUSE = "uk.org.ngo.squeezer.service.ACTION_PAUSE";
    private static final String ACTION_CLOSE = "uk.org.ngo.squeezer.service.ACTION_CLOSE";

    private final BroadcastReceiver deviceIdleModeReceiver = new BroadcastReceiver() {
        @Override
        @RequiresApi(api = Build.VERSION_CODES.M)
        public void onReceive(Context context, Intent intent) {
            // On M and above going in to Doze mode suspends the network but does not shut down
            // existing network connections or cause them to generate exceptions. Explicitly
            // disconnect here, so that resuming from Doze mode forces a reconnect. See
            // https://github.com/nikclayton/android-squeezer/issues/177.
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);

                if (pm.isDeviceIdleMode()) {
                    Log.d(TAG, "Entering doze mode, disconnecting");
                    disconnect(false);
                }
            }
        }
    };

    private MyVolumeProvider mVolumeProvider;

    /**
     * Thrown when the service is asked to send a command to the server before the server
     * handshake completes.
     */
    public static class HandshakeNotCompleteException extends IllegalStateException {
        public HandshakeNotCompleteException() {
            super();
        }

        public HandshakeNotCompleteException(String message) {
            super(message);
        }

        public HandshakeNotCompleteException(String message, Throwable cause) {
            super(message, cause);
        }

        public HandshakeNotCompleteException(Throwable cause) {
            super(cause);
        }
    }

    @Override
    public void onCreate() {
        super.onCreate();

        // Clear leftover notification in case this service previously got killed while playing
        NotificationManagerCompat nm = NotificationManagerCompat.from(this);
        nm.cancel(PLAYBACKSERVICE_STATUS);

        Squeezer.getPreferences(preferences -> cachePreferences(preferences));

        WifiManager wifiManager = (WifiManager) getApplicationContext().getSystemService(Context.WIFI_SERVICE);
        this.wifiLock = wifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL, "Squeezer_WifiLock");

        mEventBus.register(this);  // Get events before other subscribers - now with Annotation

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            registerReceiver(deviceIdleModeReceiver, new IntentFilter(
                    PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED));
        }
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        try{
            if(intent != null && intent.getAction()!= null ) {
                switch (intent.getAction()) {
                    case ACTION_NEXT_TRACK:
                        squeezeService.nextTrack();
                        break;
                    case ACTION_PREV_TRACK:
                        squeezeService.previousTrack();
                        break;
                    case ACTION_PLAY:
                        squeezeService.play();
                        break;
                    case ACTION_PAUSE:
                        squeezeService.pause();
                        break;
                    case ACTION_CLOSE:
                        squeezeService.disconnect();
                        break;
                }
            }
        } catch(Exception e) {
            Log.w(TAG, "Error executing intent: ", e);
        }
        return START_STICKY;
    }

    /**
     * Cache the value of various preferences.
     */
    private void cachePreferences(Preferences preferences) {
        scrobblingEnabled = preferences.isScrobbleEnabled();
        mFadeInSecs = preferences.getFadeInSecs();
        mGroupVolume = preferences.isGroupVolume();
        mVolumeProvider = new MyVolumeProvider(preferences.getVolumeIncrements());
        if (squeezeService.isConnected()) {
            if (preferences.isBackgroundVolume()) {
                mMediaSession.setPlaybackToRemote(mVolumeProvider);
            } else {
                mMediaSession.setPlaybackToLocal(AudioManager.STREAM_MUSIC);
            }
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        mMediaSession = new MediaSessionCompat(getApplicationContext(), "squeezer");
        return (IBinder) squeezeService;
    }

    @Override
    public boolean onUnbind(Intent intent) {
        if (mMediaSession != null) {
            mMediaSession.release();
        }
        return super.onUnbind(intent);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        disconnect(false);
        mEventBus.unregister(this);

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            try {
                unregisterReceiver(deviceIdleModeReceiver);
            } catch (IllegalArgumentException e) {
                // Do nothing. This can occur in testing when we destroy the service before the
                // receiver is registered.
            }
        }
    }

    @Override
    public void onTaskRemoved(Intent rootIntent) {
        disconnect(false);
        super.onTaskRemoved(rootIntent);
    }

    void disconnect(boolean fromUser) {
        mDelegate.disconnect(fromUser);
    }

    @Nullable public PlayerState getActivePlayerState() {
        Player activePlayer = mDelegate.getActivePlayer();
        return activePlayer == null ? null : activePlayer.getPlayerState();

    }

    /**
     * Updates the playing status of the current player.
     * <p>
     * Updates the Wi-Fi lock and ongoing status notification as necessary.
     */

    @Subscribe(priority = 1)
    public void onEvent(PlayStatusChanged event) {
        if (event.player.equals(mDelegate.getActivePlayer())) {
            int state = PlayerState.PLAY_STATE_PLAY.equals(event.playStatus) ? PlaybackStateCompat.STATE_PLAYING : PlaybackStateCompat.STATE_STOPPED;
            mMediaSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(state, 0, 0).build());
            updateOngoingNotification();
            if (PlayerState.PLAY_STATE_PLAY.equals(event.playStatus)) musicPaused = false;
        }
    }

    /**
     * Change the player that is controlled by Squeezer (the "active" player).
     *
     * @param newActivePlayer The new active player. May be null, in which case no players
     *     are controlled.
     */
    private void changeActivePlayer(@Nullable final Player newActivePlayer) {
        Player prevActivePlayer = mDelegate.getActivePlayer();

        // Do nothing if the player hasn't actually changed.
        if (prevActivePlayer == newActivePlayer) {
            return;
        }

        Log.i(TAG, "Active player now: " + newActivePlayer);
        mDelegate.setActivePlayer(newActivePlayer);

        if (prevActivePlayer != null) {
            mDelegate.subscribeDisplayStatus(prevActivePlayer, false);
            mDelegate.subscribeMenuStatus(prevActivePlayer, false);
        }

        updateAllPlayerSubscriptionStates();
        requestPlayerData();
        Squeezer.getPreferences().setLastPlayer(newActivePlayer);
    }

    class JiveItemServiceItemListCallback implements IServiceItemListCallback<JiveItem> {

        private final List<JiveItem> homeMenu = new ArrayList<>();

        @Override
        public void onItemsReceived(int count, int start, Map<String, Object> parameters, List<JiveItem> items, Class<JiveItem> dataType) {
            homeMenu.addAll(items);
            if (homeMenu.size() == count) {
                Preferences preferences = Squeezer.getPreferences();
                boolean useArchive = preferences.getCustomizeHomeMenuMode() != Preferences.CustomizeHomeMenuMode.DISABLED;
                List<String> archivedMenuItems = Collections.emptyList();
                if ((useArchive) && (mDelegate.getActivePlayer() != null)) {
                    archivedMenuItems = preferences.getArchivedMenuItems(mDelegate.getActivePlayer());
                }
                Map<String, Map<String, Object>> customShortcuts = preferences.restoreCustomShortcuts();
                mDelegate.setHomeMenu(homeMenu, archivedMenuItems, customShortcuts);
            }
        }

        @Override
        public Object getClient() {
            return SqueezeService.this;
        }
    }


    private void requestPlayerData() {
        Player activePlayer = mDelegate.getActivePlayer();

        if (activePlayer != null) {
            mDelegate.subscribeDisplayStatus(activePlayer, true);
            mDelegate.subscribeMenuStatus(activePlayer, true);
            mDelegate.requestPlayerStatus(activePlayer);
            // Start an asynchronous fetch of the squeezeservers "home menu" items
            // See http://wiki.slimdevices.com/index.php/SqueezePlayAndSqueezeCenterPlugins
            mDelegate.requestItems(activePlayer, 0, new JiveItemServiceItemListCallback())
                    .cmd("menu").param("direct", "1").exec();
        }
    }

    /**
     * Adjusts the subscription to players' status updates.
     */
    private void updateAllPlayerSubscriptionStates() {
        for (Player player : mDelegate.getPlayers().values()) {
            updatePlayerSubscription(player, calculateSubscriptionTypeFor(player));
        }
    }

    /**
     * Determine the correct status subscription type for the given player, based on
     * how frequently we need to know its status.
     */
    private PlayerState.PlayerSubscriptionType calculateSubscriptionTypeFor(Player player) {
        return PlayerState.PlayerSubscriptionType.NOTIFY_ON_CHANGE;
    }

    /**
     * Manage subscription to a player's status updates.
     *
     * @param player player to manage.
     * @param playerSubscriptionType the new subscription type
     */
    private void updatePlayerSubscription(
            Player player,
            @NonNull PlayerState.PlayerSubscriptionType playerSubscriptionType) {
        PlayerState playerState = player.getPlayerState();

        // Do nothing if the player subscription type hasn't changed.
        if (playerState.getSubscriptionType().equals(playerSubscriptionType)) {
            return;
        }

        mDelegate.subscribePlayerStatus(player, playerSubscriptionType);
    }

    /**
     * Manages the state of any ongoing notification based on the player and connection state.
     */
    private void updateOngoingNotification() {
        PlayerState activePlayerState = getActivePlayerState();

        // Update scrobble state, if either we're currently scrobbling, or we
        // were (to catch the case where we started scrobbling a song, and the
        // user went in to settings to disable scrobbling).
        if (scrobblingEnabled || scrobblingPreviouslyEnabled) {
            scrobblingPreviouslyEnabled = scrobblingEnabled;
            Scrobble.scrobbleFromPlayerState(this, activePlayerState);
        }

        NotificationState notificationState = notificationState();

        // Compare the current state with the state when the notification was last updated.
        // If there are no changes (same song, same playing state) then there's nothing to do.
        if (notificationState.equals(ongoingNotification)) {
            return;
        }
        ongoingNotification = notificationState;

        final NotificationManagerCompat nm = NotificationManagerCompat.from(this);
        final NotificationData notificationData = new NotificationData(notificationState);
        final MediaMetadataCompat.Builder metaBuilder = new MediaMetadataCompat.Builder();
        metaBuilder.putString(MediaMetadata.METADATA_KEY_ARTIST, notificationState.artistName);
        metaBuilder.putString(MediaMetadata.METADATA_KEY_ALBUM, notificationState.albumName);
        metaBuilder.putString(MediaMetadata.METADATA_KEY_TITLE, notificationState.songName);
        mMediaSession.setMetadata(metaBuilder.build());

        ImageFetcher.getInstance(this).loadImage(notificationState.artworkUrl,
                getResources().getDimensionPixelSize(android.R.dimen.notification_large_icon_width),
                getResources().getDimensionPixelSize(android.R.dimen.notification_large_icon_height),
                (data, bitmap) -> {
                    if (bitmap == null) {
                        bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.icon_no_artwork);
                    }

                    metaBuilder.putBitmap(MediaMetadata.METADATA_KEY_ALBUM_ART, bitmap);
                    metaBuilder.putBitmap(MediaMetadata.METADATA_KEY_ART, bitmap);
                    mMediaSession.setMetadata(metaBuilder.build());
                    notificationData.builder.setLargeIcon(bitmap);
                    nm.notify(PLAYBACKSERVICE_STATUS, notificationData.builder.build());
                });
    }

    private class NotificationData {
        private final NotificationCompat.Builder builder;

        /**
         * Prepare a notification builder from the supplied notification state.
         */
        private NotificationData(NotificationState notificationState) {
            PendingIntent nextPendingIntent = getPendingIntent(ACTION_NEXT_TRACK);
            PendingIntent prevPendingIntent = getPendingIntent(ACTION_PREV_TRACK);
            PendingIntent playPendingIntent = getPendingIntent(ACTION_PLAY);
            PendingIntent pausePendingIntent = getPendingIntent(ACTION_PAUSE);
            PendingIntent closePendingIntent = getPendingIntent(ACTION_CLOSE);

            Intent showNowPlaying = new Intent(SqueezeService.this, NowPlayingActivity.class)
                    .setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
            PendingIntent pIntent = PendingIntent.getActivity(SqueezeService.this, 0, showNowPlaying, Intents.immutablePendingIntent());


            NotificationUtil.createNotificationChannel(SqueezeService.this, NOTIFICATION_CHANNEL_ID,
                    "Squeezer ongoing notification",
                    "Notifications of player and connection state",
                    NotificationManagerCompat.IMPORTANCE_LOW, false, NotificationCompat.VISIBILITY_PUBLIC);
            builder = new NotificationCompat.Builder(SqueezeService.this, NOTIFICATION_CHANNEL_ID);

            builder.setContentIntent(pIntent);
            builder.setSmallIcon(R.drawable.squeezer_notification);
            builder.setVisibility(NotificationCompat.VISIBILITY_PUBLIC);
            builder.setShowWhen(false);
            builder.setContentTitle(notificationState.songName);
            builder.setContentText(notificationState.artistAlbum());
            builder.setSubText(notificationState.player());
            builder.setStyle(new androidx.media.app.NotificationCompat.MediaStyle()
                    .setShowActionsInCompactView(2, 3)
                    .setMediaSession(mMediaSession.getSessionToken()));

            // Don't set an ongoing notification, otherwise wearable's won't show it.
            builder.setOngoing(false);

            builder.setDeleteIntent(closePendingIntent);
            builder.addAction(new NotificationCompat.Action(R.drawable.ic_action_disconnect, "Disconnect", closePendingIntent));
            builder.addAction(new NotificationCompat.Action(R.drawable.ic_action_previous, "Previous", prevPendingIntent));
            if (notificationState.playing) {
                builder.addAction(new NotificationCompat.Action(R.drawable.ic_action_pause, "Pause", pausePendingIntent));
            } else {
                builder.addAction(new NotificationCompat.Action(R.drawable.ic_action_play, "Play", playPendingIntent));
            }
            builder.addAction(new NotificationCompat.Action(R.drawable.ic_action_next, "Next", nextPendingIntent));
        }
    }

    /**
     * Build current notification state based on the player and connection state.
     */
    private NotificationState notificationState() {
        NotificationState notificationState = new NotificationState();

        final Player activePlayer = mDelegate.getActivePlayer();
        notificationState.hasPlayer = (activePlayer != null);
        if (notificationState.hasPlayer) {
            final PlayerState activePlayerState = activePlayer.getPlayerState();

            notificationState.playing = activePlayerState.isPlaying();
            notificationState.currentTrack = activePlayerState.getCurrentPlaylistIndex()+1;
            notificationState.numTracks = activePlayerState.getCurrentPlaylistTracksNum();

            final CurrentPlaylistItem currentSong = activePlayerState.getCurrentSong();
            notificationState.hasSong = (currentSong != null);
            if (currentSong != null) {
                notificationState.songName = currentSong.getName();
                notificationState.albumName = currentSong.getAlbum();
                notificationState.artistName = currentSong.getArtist();
                notificationState.artworkUrl = currentSong.getIcon();
                notificationState.playerName = activePlayer.getName();
            }
        }

        return notificationState;
    }

    /**
     * @param action The action to be performed.
     * @return A new {@link PendingIntent} for {@literal action} that will update any existing
     *     intents that use the same action.
     */
    @NonNull
    private PendingIntent getPendingIntent(@NonNull String action){
        Intent intent = new Intent(this, SqueezeService.class);
        intent.setAction(action);

        return PendingIntent.getService(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT | Intents.immutablePendingIntent());
    }

    private void startForeground() {
        if (!foreGround) {
            Log.i(TAG, "startForeground");
            foreGround = true;

            if (!wifiLock.isHeld()) {
                wifiLock.acquire();
            }

            NotificationState notificationState = notificationState();
            NotificationData notificationData = new NotificationData(notificationState);
            Notification notification = notificationData.builder.build();

            mMediaSession.setCallback(new MediaSessionCompat.Callback() {

                @Override
                public void onPlay() {
                    squeezeService.play();
                }

                @Override
                public void onPause() {
                    squeezeService.pause();
                }

                @Override
                public void onSkipToNext() {
                    squeezeService.nextTrack();
                }

                @Override
                public void onSkipToPrevious() {
                    squeezeService.previousTrack();
                }
            });

            final MediaMetadataCompat.Builder metaBuilder = new MediaMetadataCompat.Builder();
            metaBuilder.putString(MediaMetadata.METADATA_KEY_ARTIST, notificationState.artistName);
            metaBuilder.putString(MediaMetadata.METADATA_KEY_ALBUM, notificationState.albumName);
            metaBuilder.putString(MediaMetadata.METADATA_KEY_TITLE, notificationState.songName);
            mMediaSession.setMetadata(metaBuilder.build());

            mMediaSession.setFlags(MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS | MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS);

            if (Squeezer.getPreferences().isBackgroundVolume()) {
                mMediaSession.setPlaybackToRemote(mVolumeProvider);
            }
            mMediaSession.setActive(true);

            // Start it and have it run forever (until it shuts itself down).
            // This is required so swapping out the activity (and unbinding the
            // service connection in onDestroy) doesn't cause the service to be
            // killed due to zero refcount.
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                startForegroundService(new Intent(this, SqueezeService.class));
            } else {
                startService(new Intent(this, SqueezeService.class));
            }

            // Call startForeground immediately after startForegroundService
            startForeground(PLAYBACKSERVICE_STATUS, notification);
        }
    }

    private void stopForeground() {
        Log.i(TAG, "stopForeground");
        foreGround = false;
        ongoingNotification = null;

        if (wifiLock.isHeld()) {
            wifiLock.release();
        }

        mMediaSession.setPlaybackToLocal(AudioManager.STREAM_MUSIC);
        mMediaSession.setActive(false);

        stopForeground(true);
        stopSelf();
    }

    private void registerCallStateListener() {
        if (!callStateListenerRegistered) {
            TelephonyManager telephonyManager = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_PHONE_STATE) == PackageManager.PERMISSION_GRANTED) {
                    Log.d(TAG, "calling registerTelephonyCallback");
                    telephonyManager.registerTelephonyCallback(getMainExecutor(), callStateListener);
                }
            } else {
                telephonyManager.listen(phoneStateListener, PhoneStateListener.LISTEN_CALL_STATE);
            }
            callStateListenerRegistered = true;
        }
    }

    private void unregisterCallStateListener() {
        if (callStateListenerRegistered) {
            TelephonyManager telephonyManager = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                telephonyManager.unregisterTelephonyCallback(callStateListener);
            } else {
                telephonyManager.listen(phoneStateListener, PhoneStateListener.LISTEN_NONE);
            }
            callStateListenerRegistered = false;
        }
    }

    @RequiresApi(api = Build.VERSION_CODES.S)
    private static abstract class CallStateListener extends TelephonyCallback implements TelephonyCallback.CallStateListener {
        @Override
        abstract public void onCallStateChanged(int state);
    }

    private boolean callStateListenerRegistered = false;
    private boolean musicPaused = false;

    private CallStateListener callStateListener = (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) ?
            new CallStateListener() {
                @Override
                public void onCallStateChanged(int state) {
                    SqueezeService.this.onCallStateChanged(state);
                }
            }
            : null;

    private PhoneStateListener phoneStateListener = (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) ?
            new PhoneStateListener() {
                @Override
                public void onCallStateChanged(int state, String phoneNumber) {
                    SqueezeService.this.onCallStateChanged(state);
                }
            }
            : null;

    private void onCallStateChanged(int state) {
        Preferences preferences = Squeezer.getPreferences();
        Preferences.IncomingCallAction incomingCallAction = preferences.getActionOnIncomingCall();
        if (incomingCallAction != Preferences.IncomingCallAction.NONE) {
            PerformAction action = null;
            boolean isPlaying = (getActivePlayerState() != null && getActivePlayerState().isPlaying());
            if (state == TelephonyManager.CALL_STATE_RINGING || state == TelephonyManager.CALL_STATE_OFFHOOK) {
                if (isPlaying) {
                    action = incomingCallAction == Preferences.IncomingCallAction.PAUSE ? squeezeService::pause : squeezeService::mute;
                    musicPaused = true;
                }
            } else {
                if (musicPaused && preferences.restoreMusicAfterCall()) {
                    action = incomingCallAction == Preferences.IncomingCallAction.PAUSE ? squeezeService::play : squeezeService::unmute;
                }
                musicPaused = false;
            }
            if (action != null) action.exec();
        }
    }

    private interface PerformAction {
        void exec();
    }

    @Subscribe(sticky = true, priority = 1)
    public void onEvent(ConnectionChanged event) {
        if (ConnectionState.isConnected(event.connectionState) ||
                ConnectionState.isConnectInProgress(event.connectionState)) {
            startForeground();
            registerCallStateListener();
        } else {
            unregisterCallStateListener();
            mHandshakeComplete = false;
            stopForeground();
        }
        musicPaused = false;
    }

    @Subscribe(sticky = true, priority = 1)
    public void onEvent(PlayerVolume event) {
        if (event.player == mDelegate.getActivePlayer()) {
            mVolumeProvider.setCurrentVolume(mDelegate.getVolume(mGroupVolume).volume / mVolumeProvider.step);
        }
    }

    @Subscribe(sticky = true, priority = 1)
    public void onEvent(HandshakeComplete event) {
        Log.d("SqueezeService", "Handshake complete");
        mHandshakeComplete = true;
    }

    @Subscribe(sticky = true, priority = 1)
    public void onEvent(MusicChanged event) {
        if (event.player.equals(mDelegate.getActivePlayer())) {
            updateOngoingNotification();
        }
        if (event.player.getPlayerState().isRandomPlaying()) {
            handleRandomOnEvent(event.player);
        }
    }

    private void handleRandomOnEvent(Player player) {

        RandomPlay randomPlay = mDelegate.getRandomPlay(player);
        Preferences preferences = Squeezer.getPreferences();
        PlayerState playerState = player.getPlayerState();

        int number = playerState.getCurrentPlaylistTracksNum();
        int index = playerState.getCurrentPlaylistIndex();
        Log.i(TAG, String.format("Random Play event for %s has number %d with index %d.", player.getName(), number, index));
        String nextTrack = randomPlay.getNextTrack();
        if (endRandomPlay(number, index)) {
            Log.i(TAG, String.format("End Random Play and reset '%s'.", player.getName()));
            randomPlay.reset(player);
        } else if (firstTwoTracksLoaded(number, index)) {
            Log.i(TAG, String.format("Ignore event after Random Play initialization for player '%s'.", player.getName()));
            return;
        } else {
            Log.i(TAG, String.format("Handle Random Play after event for player '%s'.", player.getName()));
            String folderID = randomPlay.getActiveFolderID();
            Set<String> tracks = randomPlay.getTracks(folderID);
            Set<String> played = preferences.loadRandomPlayed(folderID);
            played.add(nextTrack);
            preferences.saveRandomPlayed(folderID, played);
            Set<String> unplayed = new HashSet<>(tracks);
            if (played.size() == tracks.size()) {
                Log.i(TAG, String.format("All Random played from folder %s on player %s. Clear!", folderID, player.getName()));
                played.clear();
                preferences.saveRandomPlayed(folderID, played);
            } else {
                unplayed.removeAll(played);
                Log.i(TAG, String.format("Loaded %s unplayed tracks from folder %s for Random Play on player %s.", unplayed.size(), folderID, player.getName()));
            }
            if (unplayed.size() > 0) {
                randomPlayDelegate.fillPlaylist(unplayed, player, nextTrack);
            } else {
                Log.e(TAG, String.format("No unplayed tracks found for Random Play in folder %s on %s!", folderID, player.getName()));
            }
        }
    }

    private boolean endRandomPlay(int number, int index) {
        // After a MusicChanged event we have to check if this meant that the last track of random
        // play is now playing. In this case we load another track. If the track changed but there
        // are more tracks in the playlist after it, it means that the user might have added tracks
        // to the end of the playlist. So we deactivate Random Play.
        // On the other hand the user might have just chosen another track from the already played
        // random tracks (currently we don't consider this).
        // TODO endRandomPlay could be better.
        if ( (number - index == 1) && (number > 1) ) {
            // last track playing
            return false;
        }
        else return !firstTwoTracksLoaded(number, index);
    }

    private boolean firstTwoTracksLoaded(int number, int index) {
        return (number - index == 2) && (number == 2);
    }

    @Subscribe(priority = 1)
    public void onEvent(PlayersChanged event) {
        Player activePlayer = mDelegate.getActivePlayer();
        if (activePlayer == null) {
            // Figure out the new active player, let everyone know.
            changeActivePlayer(getPreferredPlayer(mDelegate.getPlayers().values()));
        } else {
            activePlayer = mDelegate.getPlayer(activePlayer.getId());
            mDelegate.setActivePlayer(activePlayer);
            updateAllPlayerSubscriptionStates();
            requestPlayerData();
        }
    }

    /**
     * @return The player that should be chosen as the (new) active player. This is either the
     *     last active player (if known), the first player the server knows about if there are
     *     connected players, or null if there are no connected players.
     */
    private @Nullable Player getPreferredPlayer(Collection<Player> players) {
        final String lastConnectedPlayer = Squeezer.getPreferences().getLastPlayer();
        Log.i(TAG, "lastConnectedPlayer was: " + lastConnectedPlayer);

        Log.i(TAG, "players empty?: " + players.isEmpty());
        for (Player player : players) {
            if (player.getId().equals(lastConnectedPlayer)) {
                return player;
            }
        }
        return !players.isEmpty() ? players.iterator().next() : null;
    }

    /** A download request will be passed to the download manager for each song called back to this */
    private final IServiceItemListCallback<Song> songDownloadCallback = new IServiceItemListCallback<Song>() {
        @Override
        public void onItemsReceived(int count, int start, Map<String, Object> parameters, List<Song> items, Class<Song> dataType) {
            final Preferences preferences = Squeezer.getPreferences();
            for (Song song : items) {
                Log.i(TAG, "downloadSong(" + song + ")");
                Uri downloadUrl = Util.getDownloadUrl(mDelegate.getUrlPrefix(), song.id);
                if (preferences.isDownloadUseServerPath()) {
                    downloadSong(downloadUrl, song.title, song.album, song.artist, getLocalFile(song.url));
                } else {
                    final String lastPathSegment = song.url.getLastPathSegment();
                    final String fileExtension = Util.getFileExtension(lastPathSegment);
                    final String localPath = song.getLocalPath(preferences.getDownloadPathStructure(), preferences.getDownloadFilenameStructure());
                    downloadSong(downloadUrl, song.title, song.album, song.artist, localPath + "." + fileExtension);
                }
            }
        }

        @Override
        public Object getClient() {
            return this;
        }
    };

    /**
     * For each item called to this:
     * If it is a folder: recursive lookup items in the folder
     * If is is a track: Enqueue a download request to the download manager
     */
    private final IServiceItemListCallback<MusicFolderItem> musicFolderDownloadCallback = new IServiceItemListCallback<MusicFolderItem>() {
        @Override
        public void onItemsReceived(int count, int start, Map<String, Object> parameters, List<MusicFolderItem> items, Class<MusicFolderItem> dataType) {
            for (MusicFolderItem item : items) {
                if ("track".equals(item.type)) {
                    Log.i(TAG, "downloadMusicFolderTrack(" + item + ")");
                    SlimCommand command = JiveItem.downloadCommand(item.id);
                    mDelegate.requestAllItems(songDownloadCallback).params(command.params).cmd(command.cmd()).exec();
                }
            }
        }

        @Override
        public Object getClient() {
            return this;
        }
    };

    private void downloadSong(@NonNull Uri url, String title, String album, String artist, String localPath) {
        Log.i(TAG, "downloadSong(" + title + "): " + url);
        if (url.equals(Uri.EMPTY)) {
            return;
        }

        if (localPath == null) {
            return;
        }

        // Convert VFAT-unfriendly characters to "_".
        localPath =  localPath.replaceAll("[?<>\\\\:*|\"]", "_");
        DownloadDatabase downloadDatabase = new DownloadDatabase(this);
        String credentials = mDelegate.getUsername() + ":" + mDelegate.getPassword();
        downloadDatabase.registerDownload(this, credentials, url, localPath, title, album, artist);
    }

    /**
     * Tries to get the path relative to the server music library.
     * <p>
     * If this is not possible resort to the last path segment of the server path.
     */
    @Nullable
    private String getLocalFile(@NonNull Uri serverUrl) {
        String serverPath = serverUrl.getPath();
        String mediaDir = null;
        String path;
        for (String dir : mDelegate.getMediaDirs()) {
            if (serverPath.startsWith(dir)) {
                mediaDir = dir;
                break;
            }
        }
        if (mediaDir != null) {
            path = serverPath.substring(mediaDir.length());
        } else {
            // Note: if serverUrl is the empty string this can return null.
            path = serverUrl.getLastPathSegment();
        }

        return path;
    }


    private WifiManager.WifiLock wifiLock;

    private final ISqueezeService squeezeService = new SqueezeServiceBinder();
    private class SqueezeServiceBinder extends Binder implements ISqueezeService {

        @Override
        @NonNull
        public EventBus getEventBus() {
            return mEventBus;
        }

        @Override
        public void mute() {
            mute(getActivePlayer(), true);
        }

        @Override
        public void unmute() {
            mute(getActivePlayer(), false);
        }

        @Override
        public void toggleMute() {
            toggleMute(getActivePlayer());
        }

        @Override
        public void toggleMute(Player player) {
            if (player != null) {
                mute(player, !player.getPlayerState().isMuted());
            }
        }

        private void mute(Player player, boolean mute) {
            if (player != null) {
                mDelegate.command(player).cmd("mixer", "muting", mute ? "1" : "0").exec();
            }
        }

        @Override
        public void setVolumeTo(Player player, int newVolume) {
            setPlayerVolume(player, newVolume);
        }

        @Override
        public boolean canAdjustVolumeForSyncGroup() {
            return mDelegate.getVolumeSyncGroup(true).size() > 1;
        }

        @Override
        public void setVolumeTo(int percentage) {
            Set<Player> syncGroup = mDelegate.getVolumeSyncGroup(mGroupVolume);

            int lowestVolume = 100;
            int higestVolume = 0;
            for (Player player : syncGroup) {
                int currentVolume = player.getPlayerState().getCurrentVolume();
                if (currentVolume < lowestVolume) lowestVolume = currentVolume;
                if (currentVolume > higestVolume) higestVolume = currentVolume;
            }
            int volumeInRange = (int) Math.round(percentage / 100.0 * (100 - (higestVolume - lowestVolume)));
            for (Player player : syncGroup) {
                int currentVolume = player.getPlayerState().getCurrentVolume();
                int volumeOffset = currentVolume - lowestVolume;
                setPlayerVolume(player, volumeOffset + volumeInRange);
            }
        }

        private void setPlayerVolume(Player player, int percentage) {
            int volume = Math.min(100, Math.max(0, percentage));
            mDelegate.command(player).cmd("mixer", "volume", String.valueOf(volume)).exec();
            player.getPlayerState().setCurrentVolume(volume);
            mEventBus.post(new PlayerVolume(player));
        }

        @Override
        public void adjustVolume(int direction) {
            Set<Player> syncGroup = mDelegate.getVolumeSyncGroup(mGroupVolume);
            int adjust = direction * mVolumeProvider.step;
            for (Player player : syncGroup) {
                int currentVolume = player.getPlayerState().getCurrentVolume();
                if (currentVolume + adjust < 0) adjust = -currentVolume;
                if (currentVolume + adjust > 100) adjust = 100 - currentVolume;
            }
            if (adjust != 0) {
                for (Player player : syncGroup) {
                    if (player.getPlayerState().isMuted()) {
                        mDelegate.command(player).cmd("mixer", "muting", "0").exec();
                        try {
                            Thread.sleep(500);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    adjustPlayerVolume(player, adjust);
                }
            }
        }

        private void adjustPlayerVolume(Player player, int adjust) {
            mDelegate.command(player).cmd("mixer", "volume", (adjust > 0 ? "+" : "") + adjust).exec();
            int currentVolume = player.getPlayerState().getCurrentVolume();
            player.getPlayerState().setCurrentVolume(currentVolume + adjust);
            mEventBus.post(new PlayerVolume(player));
        }

        @Override
        public boolean isConnected() {
            return mDelegate.isConnected();
        }

        @Override
        public boolean isConnectInProgress() {
            return mDelegate.isConnectInProgress();
        }

        @Override
        public boolean canAutoConnect() {
            return mDelegate.canAutoConnect();
        }

        @Override
        public void startConnect(boolean autoConnect) {
            mDelegate.startConnect(SqueezeService.this, autoConnect);
        }

        @Override
        public void disconnect() {
            if (!isConnected()) {
                return;
            }
            SqueezeService.this.disconnect(true);
        }

        @Override
        public void register(IServiceItemListCallback<JiveItem> callback) throws SqueezeService.HandshakeNotCompleteException {
            if (!mHandshakeComplete) {
                throw new HandshakeNotCompleteException("Handshake with server has not completed.");
            }
            // We register ourselves as a player. This will come back in serverstatus, so we get an
            // active player, which is required for the register_sn command:
            // [ "playerid", [ "register_sn", 0, 100, "login_password", "email:...", "password:..." ] ]
            // We then start register flow with the command:
            // [ "", [ "register", 0, 100, "login_password", "service:SN" ] ]
            // This is same command squeezeplay uses, and allows connect to an existing account or
            // create a new.
            // This way we can use server side logic and we don't have to store account credentials
            // locally.
            String macId = Squeezer.getPreferences().getMacId();
            mDelegate.command().cmd("playerRegister", null, macId, "Squeezer-" + Build.MODEL).exec();
            mDelegate.requestItems(callback).cmd("register").param("service", "SN").exec();
        }

        @Override
        public void togglePower(Player player) {
            mDelegate.command(player).cmd("power").exec();
        }

        @Override
        public void playerRename(Player player, String newName) {
            mDelegate.command(player).cmd("name", newName).exec();
        }

        @Override
        public void sleep(Player player, int duration) {
            mDelegate.command(player).cmd("sleep", String.valueOf(duration)).exec();
        }

        @Override
        public void syncPlayerToPlayer(@NonNull Player slave, @NonNull String masterId) {
            Player master = mDelegate.getPlayer(masterId);
            mDelegate.command(master).cmd("sync", slave.getId()).exec();
        }

        @Override
        public void unsyncPlayer(@NonNull Player player) {
            mDelegate.command(player).cmd("sync", "-").exec();
        }


        @Override
        @Nullable
        public PlayerState getActivePlayerState() {
            Player activePlayer = getActivePlayer();
            if (activePlayer == null) {
                return null;
            }

            return activePlayer.getPlayerState();
        }

        @Override
        public void playerPref(Player.Pref playerPref, String value) {
            mDelegate.activePlayerCommand().cmd("playerpref", playerPref.prefName(), value).exec();
        }

        @Override
        public void playerPref(Player player, Player.Pref playerPref, String value) {
            mDelegate.command(player).cmd("playerpref", playerPref.prefName(), value).exec();
        }

        @Override
        public String getServerVersion() throws HandshakeNotCompleteException {
            if (!mHandshakeComplete) {
                throw new HandshakeNotCompleteException("Handshake with server has not completed.");
            }
            return mDelegate.getServerVersion();
        }

        private String fadeInSecs() {
            return mFadeInSecs > 0 ? " " + mFadeInSecs : "";
        }

        @Override
        public boolean togglePausePlay() {
            return togglePausePlay(getActivePlayer());
        }
        @Override
        public boolean togglePausePlay(Player player) {
            if (!isConnected()) {
                return false;
            }


            // May be null (e.g., connected to a server with no connected
            // players. TODO: Handle this better, since it's not obvious in the
            // UI.
            if (player == null)
                return false;

            PlayerState activePlayerState = player.getPlayerState();
            @PlayerState.PlayState String playStatus = activePlayerState.getPlayStatus();

            // May be null -- race condition when connecting to a server that
            // has a player. Squeezer knows the player exists, but has not yet
            // determined its state.
            if (playStatus == null)
                return false;

            if (playStatus.equals(PlayerState.PLAY_STATE_PLAY)) {
                // NOTE: we never send ambiguous "pause" toggle commands (without the '1')
                // because then we'd get confused when they came back in to us, not being
                // able to differentiate ours coming back on the listen channel vs. those
                // of those idiots at the dinner party messing around.
                mDelegate.command(player).cmd("pause", "1").exec();
                return true;
            }

            if (playStatus.equals(PlayerState.PLAY_STATE_STOP)) {
                mDelegate.command(player).cmd("play", fadeInSecs()).exec();
                return true;
            }

            if (playStatus.equals(PlayerState.PLAY_STATE_PAUSE)) {
                mDelegate.command(player).cmd("pause", "0", fadeInSecs()).exec();
                return true;
            }

            return true;
        }

        @Override
        public boolean play() {
            if (!isConnected()) {
                return false;
            }
            mDelegate.activePlayerCommand().cmd("play", fadeInSecs()).exec();
            return true;
        }

        @Override
        public boolean pause() {
            if(!isConnected()) {
                return false;
            }
            mDelegate.activePlayerCommand().cmd("pause", "1", fadeInSecs()).exec();
            return true;
        }

        @Override
        public boolean stop() {
            if (!isConnected()) {
                return false;
            }
            mDelegate.activePlayerCommand().cmd("stop").exec();
            return true;
        }

        @Override
        public boolean nextTrack() {
            return nextTrack(getActivePlayer());
        }
        @Override
        public boolean nextTrack(Player player) {
            if (!isConnected() || !isPlaying()) {
                return false;
            }
            mDelegate.command(player).cmd("button", "jump_fwd").exec();
            return true;
        }

        @Override
        public boolean previousTrack() {
            return previousTrack(getActivePlayer());
        }

        @Override
        public boolean previousTrack(Player player) {
            if (!isConnected() || !isPlaying()) {
                return false;
            }
            mDelegate.command(player).cmd("button", "jump_rew").exec();
            return true;
        }

        @Override
        public boolean toggleShuffle() {
            if (!isConnected()) {
                return false;
            }
            mDelegate.activePlayerCommand().cmd("button", "shuffle").exec();
            return true;
        }

        @Override
        public boolean toggleRepeat() {
            if (!isConnected()) {
                return false;
            }
            mDelegate.activePlayerCommand().cmd("button", "repeat").exec();
            return true;
        }

        /**
         * Start playing the song in the current playlist at the given index.
         *
         * @param index the index to jump to
         */
        @Override
        public boolean playlistIndex(int index) {
            if (!isConnected()) {
                return false;
            }
            mDelegate.activePlayerCommand().cmd("playlist", "index", String.valueOf(index), fadeInSecs()).exec();
            return true;
        }

        @Override
        public boolean playlistRemove(int index) {
            if (!isConnected()) {
                return false;
            }
            mDelegate.activePlayerCommand().cmd("playlist" ,"delete", String.valueOf(index)).exec();
            return true;
        }

        @Override
        public boolean playlistMove(int fromIndex, int toIndex) {
            if (!isConnected()) {
                return false;
            }
            mDelegate.activePlayerCommand().cmd("playlist", "move", String.valueOf(fromIndex), String.valueOf(toIndex)).exec();
            return true;
        }

        @Override
        public boolean playlistClear() {
            if (!isConnected()) {
                return false;
            }
            mDelegate.activePlayerCommand().cmd("playlist", "clear").exec();
            return true;
        }

        @Override
        public boolean playlistSave(String name) {
            if (!isConnected()) {
                return false;
            }
            mDelegate.activePlayerCommand().cmd("playlist", "save", name).exec();
            return true;
        }

        @Override
        public boolean button(Player player, IRButton button) {
            if (!isConnected()) {
                return false;
            }
            mDelegate.command(player).cmd("button", button.getFunction()).exec();
            return true;
        }

        private boolean isPlaying() {
            PlayerState playerState = getActivePlayerState();
            return playerState != null && playerState.isPlaying();
        }

        @Override
        public void setActivePlayer(@Nullable final Player newActivePlayer) {
            changeActivePlayer(newActivePlayer);
        }

        @Override
        @Nullable
        public Player getActivePlayer() {
            return mDelegate.getActivePlayer();
        }

        @Override
        public List<Player> getPlayers() {
            return mDelegate.getPlayers().values().stream().filter(Player::getConnected).sorted().collect(Collectors.toList());
        }

        @Override
        public Player getPlayer(String playerId) throws PlayerNotFoundException {
            Player player = mDelegate.getPlayer(playerId);
            if (player == null) {
                throw new PlayerNotFoundException(SqueezeService.this);
            }
            return player;
        }

        @Override
        public @NonNull VolumeInfo getVolume() {
            return mDelegate.getVolume(mGroupVolume);
        }

        /**
         * @return null if there is no active player, otherwise the name of the current playlist,
         *     which may be the empty string.
         */
        @Override
        @Nullable
        public String getCurrentPlaylist() {
            PlayerState playerState = getActivePlayerState();

            if (playerState == null)
                return null;

            return playerState.getCurrentPlaylist();
        }

        @Override
        public void setSecondsElapsed(int seconds) {
            if (isConnected() && seconds >= 0) {
                mDelegate.activePlayerCommand().cmd("time", String.valueOf(seconds)).exec();
            }
        }

        @Override
        public void adjustSecondsElapsed(int seconds) {
            if (isConnected()) {
                mDelegate.activePlayerCommand().cmd("time", (seconds > 0 ? "+" : "") + seconds).exec();
            }
        }

        @Override
        public void preferenceChanged(Preferences preferences, String key) {
            Log.i(TAG, "Preference changed: " + key);
            if (Preferences.KEY_CUSTOMIZE_HOME_MENU_MODE.equals(key)) {
                boolean useArchive = preferences.getCustomizeHomeMenuMode() != Preferences.CustomizeHomeMenuMode.DISABLED;
                List<String> archivedMenuItems = Collections.emptyList();
                if ((useArchive) && (getActivePlayer() != null)) {
                    archivedMenuItems = preferences.getArchivedMenuItems(getActivePlayer());
                }
                Map<String, Map<String, Object>> customShortcuts = preferences.restoreCustomShortcuts();
                mDelegate.setHomeMenu(archivedMenuItems, customShortcuts);
            } else if (Preferences.KEY_CUSTOMIZE_SHORTCUT_MODE.equals(key)) {
                if (preferences.getCustomizeShortcutsMode() == Preferences.CustomizeShortcutsMode.DISABLED) {
                    mDelegate.getHomeMenuHandling().removeAllShortcuts();
                    preferences.saveShortcuts(preferences.convertShortcuts(mDelegate.getHomeMenuHandling().customShortcuts)); // TODO check for simplification
                }
            } else if (Preferences.KEY_ACTION_ON_INCOMING_CALL.equals(key)) {
                if (preferences.getActionOnIncomingCall() != Preferences.IncomingCallAction.NONE) {
                    registerCallStateListener();
                }
            } else {
                cachePreferences(preferences);
            }
        }


        @Override
        public void cancelItemListRequests(Object client) {
            mDelegate.cancelClientRequests(client);
        }

        @Override
        public void alarms(int start, IServiceItemListCallback<Alarm> callback) {
            if (!isConnected()) {
                return;
            }
            mDelegate.requestItems(getActivePlayer(), start, callback).cmd("alarms").param("filter", "all").exec();
        }

        @Override
        public void alarmPlaylists(IServiceItemListCallback<AlarmPlaylist> callback) {
            if (!isConnected()) {
                return;
            }
            // The LMS documentation states that
            // The "alarm playlists" returns all the playlists, sounds, favorites etc. available to alarms.
            // This will however return only one playlist: the current playlist.
            // Inspection of the LMS code reveals that the "alarm playlists" command takes the
            // customary <start> and <itemsPerResponse> parameters, but these are interpreted as
            // categories (eg. Favorites, Natural Sounds etc.), but the returned list is flattened,
            // i.e. contains all items of the requested categories.
            // So we order all playlists without paging.
            mDelegate.requestItems(callback).cmd("alarm", "playlists").exec();
        }

        @Override
        public void alarmAdd(int time) {
            if (!isConnected()) {
                return;
            }
            mDelegate.activePlayerCommand().cmd("alarm", "add").param("time", time).exec();
        }

        @Override
        public void alarmDelete(String id) {
            if (!isConnected()) {
                return;
            }
            mDelegate.activePlayerCommand().cmd("alarm", "delete").param("id", id).exec();
        }

        @Override
        public void alarmSetTime(String id, int time) {
            if (!isConnected()) {
                return;
            }
            mDelegate.activePlayerCommand().cmd("alarm", "update").param("id", id).param("time", time).exec();
        }

        @Override
        public void alarmAddDay(String id, int day) {
            mDelegate.activePlayerCommand().cmd("alarm", "update").param("id", id).param("dowAdd", day).exec();
        }

        @Override
        public void alarmRemoveDay(String id, int day) {
            mDelegate.activePlayerCommand().cmd("alarm", "update").param("id", id).param("dowDel", day).exec();
        }

        @Override
        public void alarmEnable(String id, boolean enabled) {
            mDelegate.activePlayerCommand().cmd("alarm", "update").param("id", id).param("enabled", enabled ? "1" : "0").exec();
        }

        @Override
        public void alarmRepeat(String id, boolean repeat) {
            mDelegate.activePlayerCommand().cmd("alarm", "update").param("id", id).param("repeat", repeat ? "1" : "0").exec();
        }

        @Override
        public void alarmSetPlaylist(String id, AlarmPlaylist playlist) {
            mDelegate.activePlayerCommand().cmd("alarm", "update").param("id", id)
                    .param("url", "".equals(playlist.getId()) ? "0" : playlist.getId()).exec();
        }

        /* Start an asynchronous fetch of the squeezeservers generic menu items */
        @Override
        public void pluginItems(int start, String cmd, IServiceItemListCallback<JiveItem>  callback) throws SqueezeService.HandshakeNotCompleteException {
            if (!mHandshakeComplete) {
                throw new HandshakeNotCompleteException("Handshake with server has not completed.");
            }
            mDelegate.requestItems(getActivePlayer(), start, callback).cmd(cmd).param("menu", "menu").exec();
        }

        /* Start an asynchronous fetch of the squeezeservers generic menu items */
        @Override
        public void pluginItems(int start, JiveItem item, Action action, IServiceItemListCallback<JiveItem>  callback) throws SqueezeService.HandshakeNotCompleteException {
            if (!mHandshakeComplete) {
                throw new HandshakeNotCompleteException("Handshake with server has not completed.");
            }
            mDelegate.requestItems(getActivePlayer(), start, callback).cmd(action.action.cmd).params(action.action.params(item.inputValue)).exec();
        }

        @Override
        public void pluginItems(Action action, IServiceItemListCallback<JiveItem> callback) throws HandshakeNotCompleteException {
            // We cant use paging for context menu items as LMS does some "magic"
            // See XMLBrowser.pm ("xmlBrowseInterimCM" and  "# Cannot do this if we might screw up paging")
            mDelegate.requestItems(getActivePlayer(), callback).cmd(action.action.cmd).params(action.action.params).exec();
        }

        @Override
        public void action(JiveItem item, Action action) {
            if (!isConnected()) {
                return;
            }
            mDelegate.command(getActivePlayer()).cmd(action.action.cmd).params(action.action.params(item.inputValue)).exec();
        }

        @Override
        public void action(Action.JsonAction action) {
            if (!isConnected()) {
                return;
            }
            mDelegate.command(getActivePlayer()).cmd(action.cmd).params(action.params).exec();
        }

        @Override
        public void downloadItem(JiveItem item) throws HandshakeNotCompleteException {
            Log.i(TAG, "downloadItem(" + item + ")");
            SlimCommand command = item.downloadCommand();
            IServiceItemListCallback<?> callback = ("musicfolder".equals(command.cmd.get(0))) ? musicFolderDownloadCallback : songDownloadCallback;
            mDelegate.requestAllItems(callback).params(command.params).cmd(command.cmd()).exec();
        }

        public Boolean randomPlayFolder(JiveItem item) {
            SlimCommand command = item.randomPlayFolderCommand();
            String folderID = (String) command.params.get("folder_id");
            if (folderID == null) {
                Log.e(TAG, "randomPlayFolder: No folder_id");
                return false;
            }
            Set<String> played = Squeezer.getPreferences().loadRandomPlayed(folderID);
            Player player = mDelegate.getActivePlayer();
            RandomPlay randomPlay = mDelegate.getRandomPlay(player);
            randomPlay.reset(player);
            RandomPlay.RandomPlayCallback randomPlayCallback
                    = randomPlay.new RandomPlayCallback(randomPlayDelegate, folderID, played);
            mDelegate.requestAllItems(randomPlayCallback)
                    .params(command.params)
                    .cmd(command.cmd())
                    .exec();
            return true;
        }

        public boolean toggleArchiveItem(JiveItem item) {
            List<String> menu = mDelegate.toggleArchiveItem(item);
            Squeezer.getPreferences().setArchivedMenuItems(menu, getActivePlayer());
            return menu.isEmpty();
        }

        @Override
        public boolean isInArchive(JiveItem item) {
           return mDelegate.isInArchive(item);
        }

        public void triggerHomeMenuEvent() {
            mDelegate.triggerHomeMenuEvent();
        }

        @Override
        public SlimDelegate getDelegate() {
            return mDelegate;
        }

        @Override
        public void removeCustomShortcut(JiveItem item) {
            mDelegate.removeCustomShortcut(item);
        }
    }

    private class MyVolumeProvider extends VolumeProviderCompat {
        private final int step;

        public MyVolumeProvider(int step) {
            super(VolumeProviderCompat.VOLUME_CONTROL_ABSOLUTE, 100 / step, 1);
            this.step = step;
        }

        @Override
        public void onAdjustVolume(int direction) {
            squeezeService.adjustVolume(direction);
        }

        @Override
        public void onSetVolumeTo(int volume) {
            squeezeService.setVolumeTo(volume * step);
        }
    }
}
